<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="mysql," />










<meta name="description" content="Mysql性能调优什么决定了双11大促的成败 web服务器 ：可以横向拓展，只要有足够的服务器。就可以部署web服务，只要web的程序是一样的；  数据库服务器：数据库要求完成性和一致性，数据并不是随便的复制拓展；所以数据库服务器的优化比较有难度。   一般公司多数公司的数据库架构都是主从架构：一个主服务器多个从服务器；master—-&gt;n个slave   一旦主服务器发生故障，只能从sla">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql调优">
<meta property="og:url" content="http://example.com/2020/10/30/mysql%E8%B0%83%E4%BC%98/index.html">
<meta property="og:site_name" content="Dbao子博客">
<meta property="og:description" content="Mysql性能调优什么决定了双11大促的成败 web服务器 ：可以横向拓展，只要有足够的服务器。就可以部署web服务，只要web的程序是一样的；  数据库服务器：数据库要求完成性和一致性，数据并不是随便的复制拓展；所以数据库服务器的优化比较有难度。   一般公司多数公司的数据库架构都是主从架构：一个主服务器多个从服务器；master—-&gt;n个slave   一旦主服务器发生故障，只能从sla">
<meta property="og:locale">
<meta property="og:image" content="https://img-blog.csdn.net/20180511181017647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhX2d1b19saQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191011191035889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdn.net/20181004102705475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20181004102938486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/2018100410311231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20160805191715603">
<meta property="og:image" content="https://img-blog.csdn.net/20160805192039968">
<meta property="og:image" content="https://img-blog.csdn.net/20160805192156312">
<meta property="article:published_time" content="2020-10-30T15:12:54.000Z">
<meta property="article:modified_time" content="2020-10-30T15:14:09.615Z">
<meta property="article:author" content="Dzh">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180511181017647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhX2d1b19saQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/10/30/mysql调优/"/>





  <title>mysql调优 | Dbao子博客</title>
  








<meta name="generator" content="Hexo 5.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dbao子博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">逗逼碼農</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/30/mysql%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dbao子博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">mysql调优</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-30T23:12:54+08:00">
                2020-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Mysql性能调优"><a href="#Mysql性能调优" class="headerlink" title="Mysql性能调优"></a>Mysql性能调优</h1><h3 id="什么决定了双11大促的成败"><a href="#什么决定了双11大促的成败" class="headerlink" title="什么决定了双11大促的成败"></a>什么决定了双11大促的成败</h3><ul>
<li><p>web服务器 ：可以横向拓展，只要有足够的服务器。就可以部署web服务，只要web的程序是一样的；</p>
</li>
<li><p>数据库服务器：数据库要求完成性和一致性，数据并不是随便的复制拓展；所以数据库服务器的优化比较有难度。 </p>
</li>
<li><p>一般公司多数公司的数据库架构都是主从架构：一个主服务器多个从服务器；master—-&gt;n个slave</p>
</li>
</ul>
<p>一旦主服务器发生故障，只能从slave服务器选择最新的来同步回master，但这个十分耗时耗资源；</p>
<ul>
<li>通过监控信息可以知道是什么影响了数据性能；如qbs，tbs；并发量和cpu使用频率，并发量：同一时间处理请求的数量。（idle指标是空闲百分比值越高cpu空闲率越高）；磁盘io（fashion io 吞吐量比普通的大得多）</li>
</ul>
<h3 id="影响数据库的因素"><a href="#影响数据库的因素" class="headerlink" title="影响数据库的因素"></a>影响数据库的因素</h3><h4 id="sql查询速度"><a href="#sql查询速度" class="headerlink" title="sql查询速度"></a>sql查询速度</h4><p> 超高的QPS和TPS</p>
<p>风险：效率低的sql</p>
<p>QPS：美妙处理的查询量</p>
<h4 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h4><p>风险：网卡io被沾满（1000Mb/8≈100MB）</p>
<p>如何避免无法连接数据库情况：</p>
<p>1.减少从服务器的数量</p>
<p>2.进行分级缓存</p>
<p>3.避免使用“select *”进行查询</p>
<p>4.分离业务网络和服务器网络</p>
<h4 id="服务器硬件"><a href="#服务器硬件" class="headerlink" title="服务器硬件"></a>服务器硬件</h4><p>大量的并发和超高的cpu使用率</p>
<p>风险：大量的并发，数据库连接池数被沾满（max——connections默认是100）</p>
<p>​            超高的cup使用率，因cpu资源耗尽而出现宕机</p>
<h4 id="磁盘io"><a href="#磁盘io" class="headerlink" title="磁盘io"></a>磁盘io</h4><p>风险： 磁盘io性能突然下降（使用更快的磁盘设备）</p>
<p>​            其他大量消耗磁盘性能计划任务（调整任务，做好磁盘维护）</p>
<h4 id="其他还会影响数据库性能"><a href="#其他还会影响数据库性能" class="headerlink" title="其他还会影响数据库性能"></a>其他还会影响数据库性能</h4><h5 id="大表给我们带来的问题："><a href="#大表给我们带来的问题：" class="headerlink" title="大表给我们带来的问题："></a>大表给我们带来的问题：</h5><pre><code>      什么是表呢：大表是相对而言的，针对不同的存储引擎是有不同的限制，indb没有限制；然而在实际情况可以发现</code></pre>
<ul>
<li>记录行数巨大，单表超过了千万行</li>
<li>表数据文件巨大，表数据文件超过10G（如日志：只有insert和少量select 几乎没有update和delete 不怎么影响到业务）</li>
</ul>
<p>大表对查询的影响：</p>
<ul>
<li><p>慢查询：很难在一定的时间内过滤出所需要的数据</p>
<p>可以用 show create table buy——logs\G</p>
</li>
<li><p>大表对DDL（数据定义）操作的影响</p>
<p>1.建立索引需要很长的时间</p>
<p>风险：</p>
<p>Mysql&lt;5.5建立索引会锁表</p>
<p>Mysql&gt;=5.5虽然不会锁表但会引起主从延迟</p>
<p>2.修改表结构需要长时间锁表</p>
<p>风险：会造成长时间的主从延迟</p>
<p>虽然在mysql5.6已经支持多线程复制但还是有一定的限制</p>
<p>影响正常的数据库操作</p>
</li>
</ul>
<p>处理方法：</p>
<p>1.分库分表把一张大表分成多个小表</p>
<p>难点：</p>
<p>​        分表主键的选择</p>
<p>​        分表后跨分区的数据的查询和统计</p>
<p>tips：会消耗大量的人力和物理还有要冒着影响后端现有业务的风险</p>
<p>2.大表的历史数据归档</p>
<p>好处：减少前后端的业务的影响</p>
<p>难点：</p>
<p>​        归档时间点的选择</p>
<p>​        如何进行归档操作</p>
<h5 id="大事务给我们带来的影响："><a href="#大事务给我们带来的影响：" class="headerlink" title="大事务给我们带来的影响："></a>大事务给我们带来的影响：</h5><ul>
<li><p>什么是事务</p>
<p>事务是数据系统区别于其他一切文件系统的重要特征之一</p>
<p>事务是一组具有原子性的sql，或者是一个独立的工作单元</p>
<p>事务符合：原子性，一致性，隔离性，持久性</p>
</li>
</ul>
<p>事务的原子性（ATOMICITY）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只有执行其中的一个部分操作； </p>
<p>事务的一致性（CONSISTENCY）:一致性是指事务将数据库从一种一致性状态转为另一种一致性转态，在事务开始之前和事务结束后数据库中的数据的完整性没有被破坏</p>
<p>事务的隔离性（ISPLATION）:隔离性要求一个事务对数据库中数据的修改，在未提交完成前对其他事务是不可见得</p>
<p>​    sql标准中定义了四种隔离级别：</p>
<p>​        未提交读：</p>
<p>在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也成为脏读（Dirty Read）。这个级别会导致很多问题，从性能上说未提交读 不会比其他的级别好太多，但缺乏其他级别的好多好处，除非有非常必要的理由，在实际的应用中一般很少使用未提交读.</p>
<p>​        提交读：</p>
<p>大多数数据库系统的默认隔离级别都是提交读： （但是MYSQL不是）。提交读：满足前面提到的隔离性的简单定义：一个事务开始时，只能看到已经提交的事务所做的修改。换句话说，一个事务从开始到提交之前，所做的任何修改对其他事务都 是不可见的。这个级别有时候也叫做不可重复的（nonerepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。</p>
<p>​        可重复读：</p>
<p>REPEATABLE READ (可重复读) 解决了脏读问题。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。但是，理论上，可重复读隔离级别还是无法解决另一个幻读（PhantomRead）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读 取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB 存储引擎通过多版并发控制（MVCC ,Multivesion Concurrency Control ）解决了幻读问题。</p>
<p>可重复读是Mysql 默认的事务隔离级别。</p>
<p>​        可串行化：</p>
<p>可串行化是最高的隔离级别。它通过强制事务串行，避免了前面说的幻读问题。简单的来说，可串行化会在读的每一行数据上 都加上锁，所以可能导致大量的超时和锁征用问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况，才可考 虑用该级别。</p>
<p>隔离级别　　　　             脏读可能性　　　　不可重复读可能性　　　　幻读可能性　　　　加锁读</p>
<p>READ UNCOMMITED　　YES　　　                       YES　　　　　　　　　　YES　　　　　　　NO</p>
<p>READ COMMITED　　　　NO　　　                      YES　　　　　　　　　　YES　　　　　　　NO</p>
<p>REPEATABLE READ　　　NO　　　                         NO　　　　　　　　　　YES　　　　　　    NO</p>
<p>SERIALIZABLE 　　　　　NO 　　                             NO　　　　　　　　　　NO　　　　　　　YES</p>
<p>tis：查询当前事务的隔离级别 show variables like ‘%iso%’</p>
<p>隔离性是有低到高；并发性能由高到低</p>
<p>事务的持久性（DURABILITY）</p>
<p>一旦事务提交，则其所做的修改是永久保存的数据库中，此时即使系统奔溃，已提交修改的数据也不会丢失；除了其他外部因素。</p>
<p>什么是大事务：</p>
<p>定义：运行时间比较长，操作的数据比较多的事务</p>
<p>风险：1.锁定太多的数据，造成大量的阻塞的锁超时</p>
<p>​            2.回滚时所需要的时间比较长</p>
<p>​            3.执行时间长，容易造成主从延迟</p>
<p>处理方法：</p>
<p>​        1.避免一次处理太多的数据，可以分批次处理</p>
<p>​        2.移出不必要的事务中的select操作，保证事务中只有必要的写操作</p>
<h3 id="什么影响了性能"><a href="#什么影响了性能" class="headerlink" title="什么影响了性能"></a>什么影响了性能</h3><h4 id="服务器硬件-1"><a href="#服务器硬件-1" class="headerlink" title="服务器硬件"></a>服务器硬件</h4><p>cup不够快，内存不够大，磁盘io不够快等</p>
<p>对于mysql:主要是cup资源和可用内存大小资源</p>
<p>当热数据远大于可用内存大小，io就成为了瓶颈；</p>
<p>网络io往往发生在大量数据被查询时候</p>
<p>当出现io瓶颈时候最有效就是升级io子系统</p>
<ul>
<li><p>如何选择cpu：</p>
<p>一般选择更多的cpu还是更好的cpu，选择cpu时候是选择主频还是核心数量？</p>
<p>例如：对于cpu密集型的是选择更好的cpu而不是多 cpu，对于mysql目前来说是不支持多cpu对同一sql并发处理，所有选择更好的cpu</p>
<p>如果提高我们系统的吞吐量并发量我们学着更多的cpu；</p>
<p>web类型应用：核心数量聚比频率重要一些；还要考虑mysql版本，注意一定不要在64位下安装了32位的服务系统</p>
<p><strong>总结：</strong></p>
<p>1.64位cup下一定要工作在64位的系统下</p>
<p>2.对于并发较高的场景CPU的数量比频率重要</p>
<p>3.对于CPU密集性场景和复杂SQL则频率越高越好</p>
</li>
<li><p>内存的选择</p>
</li>
</ul>
<p>内存的主频越高速度越快，选择时候应选择主板支持的最大内存频率。服务器内存是组成购买升级的，每个通道的内存：相同的品牌、颗粒，频率、电压、校验技术和型号。单条容量尽可能大。（根据数据库的大小选择内存）。</p>
<p>内存的大小直接影响数据的性能：</p>
<p>内存io效率远远高于磁盘；</p>
<p>数据缓存在内存中进行读取能大大提高读写性能：</p>
<p>数据—–&gt;内存—–&gt;数据库</p>
<p>常用的mysql存储引擎中</p>
<p>MyIsqm——&gt;索引——-&gt;内存 而数据则是 MyIsqm——&gt;数据——-&gt;OS</p>
<p>InnoDB——-&gt;索引和数据——-&gt;内存</p>
<p>提示：虽然内存越多越好但同时对性能的影响是有限的不能无限增加内存来提高性能，</p>
<p>​            多余的内存增加操作系统等其他服务的性能</p>
<p><strong>总结：</strong></p>
<p>1.选择主板所能使用的最高频率的内存</p>
<p>2.内存的大小对性能很重要，所以尽可能越大</p>
<ul>
<li><p><strong>io子系统性能</strong></p>
<p>磁盘的配置和选择</p>
<p>常用的;</p>
<p>1、使用传统机械磁盘</p>
<p>2、使用RAID增强传统机械硬盘的性能</p>
<p>3、使用固态存储的ssd和pcie卡</p>
<p>4、使用网咯存储NAS和SAN</p>
<p><strong>使用传统机械磁盘</strong>:最常见、价格低、使用最多、存储空间大、读写交慢</p>
<p>传统的机械硬盘的读取数据过程：（1和2所需要的时间我们称访问时间 3我们称为传输速度）</p>
<p>1、移动磁头到磁盘表面上的正确位置</p>
<p>2、等待磁盘旋转，使的所需的数据在磁头之下</p>
<p>3、等待磁头旋转过去，所有所需的数据都被磁头读出</p>
<p>选择：1、存储容量 2、传输速度3、访问时间4、主轴转速5、物理的尺寸</p>
<p><strong>使用RAID增强传统机械硬盘的性能</strong>：RAID是磁盘的冗余队列的简称，简单来说就是RAID的作用是可以把多个较小的磁盘组成一个容量更大的磁盘，并且提供数据冗余来保证数据的完整性的技术</p>
<p>主要的RAID的级别：</p>
<p>RAID 0 最简单，成本低，只需要两块或以上的硬盘即可，没有提供冗余或者错误修复能力。（类似多个磁盘串联，在成本或性能上可能是现价比最高的但考虑到数据的恢复和可靠性则是成本最高的，因为这没有数据的冗余，数据损害的程度可能比单个的还高）</p>
<p>RAID 1 磁盘镜像 最大限度保证系统的可靠性和可修复性。硬盘使用率较低，具有很好的磁盘冗余能力和读性能，成本较高，在更换硬盘时候性能会有所下降，较多使用于存放日志或者类似工作</p>
<p>RAID5  分布式奇偶校验磁盘阵列 通过分布式奇偶校验快把数据分散到多个磁盘上，这样如果任何一个磁盘数据失效，都可以从奇偶校验快中重建，但是如果两块磁盘失效，则整个卷的数据都无法恢复。（每个存储单元的成本而言是最经济的，整个只需要一个额外的磁盘的存储空间，写比较慢，每次要写在磁盘中进行两次读和两次写来计算奇偶校验位，而顺序读随机读比较快，比较时候主要读的数据库架构），而主要的性能问题在于磁盘失效中，数据需要重新分布到磁盘中严重影响磁盘性能，最好使用在主从服务器中</p>
<p>RAID 10 分片的镜像 是对磁盘先做了RAID1之后对两组RAID1的磁盘再走RAID0，所以对读写都有良好的性能，对于RAID5重构起来更简单，速度也更快。假如其中一块磁盘损坏则性能会大幅度下降</p>
</li>
</ul>
<ul>
<li><table>
<thead>
<tr>
<th>等级</th>
<th>概要</th>
<th>冗余</th>
<th>盘数</th>
<th>读快</th>
<th>写快</th>
</tr>
</thead>
<tbody><tr>
<td>RAID 0</td>
<td>便宜、快速、危险</td>
<td>No</td>
<td>N</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>RAID 1</td>
<td>高速度、简单、安全</td>
<td>Yes</td>
<td>2（通常）</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>RAID 5</td>
<td>安全（速度）成本折中</td>
<td>Yes</td>
<td>N+1</td>
<td>Yes</td>
<td>依赖于最慢的盘</td>
</tr>
<tr>
<td>RAID 10</td>
<td>昂贵、高速、安全</td>
<td>Yes</td>
<td>2N</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>RAID 50</td>
<td>通常为极大的数据存储服务</td>
<td>Yes</td>
<td>2(N+1)</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>使用固态存储的ssd和pcie卡</strong>:固态存储，闪存。</p>
<p>特点：相比机械硬盘，固态磁盘有更好的随机读写性能</p>
<p>​           相比机械硬盘固态盘能更好的支持并发</p>
<p>​            相比机械磁盘固态盘更容易损坏（有个擦除动作）</p>
<p>ssd：1、直接使用SATA接口，可用替换传统的磁盘而不需要任何改变，2、SATA接口的ssd同样支持RAID技术；</p>
<p>PCIE-SSD：1、无法使用SATA接口需要独立的驱动和配置，价格相对于ssd要贵但性能比ssd更好</p>
<p>使用场景：适用于大量随机的IO的场景；使用于解决单线程的负载的IO瓶颈</p>
<p><strong>总结：</strong></p>
<p>PCIE-&gt;-SSD-&gt;RAID-&gt;磁盘-&gt;SAN</p>
<p><strong>网络存储SAN和NAS</strong>：SAN和NAS是两种外部文件存储设备加载到服务器上的方法；</p>
<p><strong>SAN：</strong></p>
<p>SAN设备通过光纤连接到服务器，设备通过块接口访问，服务器可以将其当做硬盘使用；</p>
<p>特点：可用承受大量的顺序读写；读写IO能可用缓存和IO合并但在随机读写不如本地的RAID磁盘，随机读写慢</p>
<p><strong>NAS：</strong></p>
<p>NAS设备使用网络连接，通过基于文件的协议如NFS或SMB来访问；</p>
<p><strong>网络存储使用场景</strong>：网络存储在顺序上面的存储性能还不错，但在随机io中就差强人意；网络存储是牺牲性能来提高高可用。比较使用数据库备份、</p>
<p><strong>网络对性能影响：</strong>延迟和带宽</p>
<ul>
<li>网络带宽对性能的影响</li>
<li>网络质量对性能影响 </li>
</ul>
<p>建议：</p>
<ul>
<li>采用高性能和高带宽的网络接口设备和交换机</li>
<li>对多个网卡进行绑定，增强可用性和宽带</li>
<li>尽可能进行网络隔离</li>
</ul>
<h4 id="服务器操作系统"><a href="#服务器操作系统" class="headerlink" title="服务器操作系统"></a>服务器操作系统</h4><p>MySQL适合的操作系统：</p>
<p>Window是对字母大小写不敏感，linux则是对字母大小写敏感。（可用通过设置mysql参数可用强制对字母大小写敏感）</p>
<p>对于CentOS系统参数优化：</p>
<p><strong>内核相关参数（etc/sysctl.conf）:</strong></p>
<p>net.core.somaxconn =65535</p>
<p>net.cor.netdev_max_backlog =65535</p>
<p>net.ipv4.tcp_max_syn_backlog =65535</p>
<p>net.ipc4.tcp_fin_timeout=10</p>
<p>net.ipc4.tcp_tw_reuse =1</p>
<p>net.ipc4.tcp_tw_recycle =1</p>
<p>….等等</p>
<h4 id="数据库存储引擎的选择"><a href="#数据库存储引擎的选择" class="headerlink" title="数据库存储引擎的选择"></a>数据库存储引擎的选择</h4><p>MyISAM：不支持事务，表级锁</p>
<p>InnoDB：事务级存储引擎，完美支持行级锁，事务的ACID特性；</p>
<h4 id="数据库参数配置"><a href="#数据库参数配置" class="headerlink" title="数据库参数配置"></a>数据库参数配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#基础配置 </span><br><span class="line">datadir=/data/datafile </span><br><span class="line">socket=/var/lib/mysql/mysql.sock </span><br><span class="line">log-error=/data/log/mysqld.log </span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid </span><br><span class="line">character_set_server=utf8 </span><br><span class="line">#允许任意IP访问 </span><br><span class="line">bind-address = 0.0.0.0 </span><br><span class="line">#是否支持符号链接，即数据库或表可以存储在my.cnf中指定datadir之外的分区或目录，为0不开启 </span><br><span class="line">#symbolic-links=0 </span><br><span class="line">#支持大小写 </span><br><span class="line">lower_case_table_names=1 </span><br><span class="line">#二进制配置 </span><br><span class="line">server-id = 1 </span><br><span class="line">log-bin = /data/log/mysql-bin.log </span><br><span class="line">log-bin-index =/data/log/binlog.index </span><br><span class="line">log_bin_trust_function_creators=1 </span><br><span class="line">expire_logs_days=7 </span><br><span class="line">#sql_mode定义了mysql应该支持的sql语法，数据校验等 </span><br><span class="line">#mysql5.0以上版本支持三种sql_mode模式：ANSI、TRADITIONAL和STRICT_TRANS_TABLES。  </span><br><span class="line">#ANSI模式：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。  </span><br><span class="line">#TRADITIONAL模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误。用于事物时，会进行事物的回滚。  </span><br><span class="line">#STRICT_TRANS_TABLES模式：严格模式，进行数据的严格校验，错误数据不能插入，报error错误。 </span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION </span><br><span class="line">#InnoDB存储数据字典、内部数据结构的缓冲池，16MB已经足够大了。 </span><br><span class="line">innodb_additional_mem_pool_size = 16M </span><br><span class="line">#InnoDB用于缓存数据、索引、锁、插入缓冲、数据字典等 </span><br><span class="line">#如果是专用的DB服务器，且以InnoDB引擎为主的场景，通常可设置物理内存的60% </span><br><span class="line">#如果是非专用DB服务器，可以先尝试设置成内存的1/4 </span><br><span class="line">innodb_buffer_pool_size = 4G </span><br><span class="line">#InnoDB的log buffer，通常设置为 64MB 就足够了 </span><br><span class="line">innodb_log_buffer_size = 64M </span><br><span class="line">#InnoDB redo log大小，通常设置256MB 就足够了 </span><br><span class="line">innodb_log_file_size = 256M </span><br><span class="line">#InnoDB redo log文件组，通常设置为 2 就足够了 </span><br><span class="line">innodb_log_files_in_group = 2 </span><br><span class="line">#共享表空间:某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1 初始化为10M。 </span><br><span class="line">#独占表空间:每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。 </span><br><span class="line">#设置参数为1启用InnoDB的独立表空间模式，便于管理 </span><br><span class="line">innodb_file_per_table = 1 </span><br><span class="line">#InnoDB共享表空间初始化大小，默认是 10MB，改成 1GB，并且自动扩展 </span><br><span class="line">innodb_data_file_path = ibdata1:1G:autoextend </span><br><span class="line">#设置临时表空间最大4G </span><br><span class="line">innodb_temp_data_file_path=ibtmp1:500M:autoextend:max:4096M </span><br><span class="line">#启用InnoDB的status file，便于管理员查看以及监控 </span><br><span class="line">innodb_status_file = 1 </span><br><span class="line">#当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。 </span><br><span class="line">#当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务。 </span><br><span class="line">#当设置为2，该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。 </span><br><span class="line">innodb_flush_log_at_trx_commit = 1 </span><br><span class="line">#设置事务隔离级别为 READ-COMMITED，提高事务效率，通常都满足事务一致性要求 </span><br><span class="line">#transaction_isolation = READ-COMMITTED  </span><br><span class="line">#max_connections：针对所有的账号所有的客户端并行连接到MYSQL服务的最大并行连接数。简单说是指MYSQL服务能够同时接受的最大并行连接数。 </span><br><span class="line">#max_user_connections : 针对某一个账号的所有客户端并行连接到MYSQL服务的最大并行连接数。简单说是指同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制。 </span><br><span class="line">#max_connect_errors：针对某一个IP主机连接中断与mysql服务连接的次数，如果超过这个值，这个IP主机将会阻止从这个IP主机发送出去的连接请求。遇到这种情况，需执行flush hosts。 </span><br><span class="line">#执行flush host或者 mysqladmin flush-hosts，其目的是为了清空host cache里的信息。可适当加大，防止频繁连接错误后，前端host被mysql拒绝掉 </span><br><span class="line">#在 show global 里有个系统状态Max_used_connections,它是指从这次mysql服务启动到现在，同一时刻并行连接数的最大值。它不是指当前的连接情况，而是一个比较值。如果在过去某一个时刻，MYSQL服务同时有10 </span><br><span class="line">00个请求连接过来，而之后再也没有出现这么大的并发请求时，则Max_used_connections=1000.请注意与show variables 里的max_user_connections的区别。#Max_used_connections / max_connections * 100% ≈ 85% </span><br><span class="line">max_connections=600 </span><br><span class="line">max_connect_errors=1000 </span><br><span class="line">max_user_connections=400 </span><br><span class="line">#设置临时表最大值，这是每次连接都会分配，不宜设置过大 max_heap_table_size 和 tmp_table_size 要设置一样大 </span><br><span class="line">max_heap_table_size = 100M </span><br><span class="line">tmp_table_size = 100M </span><br><span class="line">#每个连接都会分配的一些排序、连接等缓冲，一般设置为 2MB 就足够了 </span><br><span class="line">sort_buffer_size = 2M </span><br><span class="line">join_buffer_size = 2M </span><br><span class="line">read_buffer_size = 2M </span><br><span class="line">read_rnd_buffer_size = 2M </span><br><span class="line">#建议关闭query cache，有些时候对性能反而是一种损害 </span><br><span class="line">query_cache_size = 0 </span><br><span class="line">#如果是以InnoDB引擎为主的DB，专用于MyISAM引擎的 key_buffer_size 可以设置较小，8MB 已足够 </span><br><span class="line">#如果是以MyISAM引擎为主，可设置较大，但不能超过4G </span><br><span class="line">key_buffer_size = 8M </span><br><span class="line">#设置连接超时阀值，如果前端程序采用短连接，建议缩短这2个值，如果前端程序采用长连接，可直接注释掉这两个选项，是用默认配置(8小时) </span><br><span class="line">#interactive_timeout = 120 </span><br><span class="line">#wait_timeout = 120 </span><br><span class="line">#InnoDB使用后台线程处理数据页上读写I/0请求的数量,允许值的范围是1-64 </span><br><span class="line">#假设CPU是2颗4核的，且数据库读操作比写操作多，可设置 </span><br><span class="line">#innodb_read_io_threads=5 </span><br><span class="line">#innodb_write_io_threads=3 </span><br><span class="line">#通过show engine innodb status的FILE I/O选项可查看到线程分配 </span><br><span class="line">#设置慢查询阀值，单位为秒 </span><br><span class="line">long_query_time = 120 </span><br><span class="line">slow_query_log=1 #开启mysql慢sql的日志 </span><br><span class="line">log_output=table,File #日志输出会写表，也会写日志文件，为了便于程序去统计，所以最好写表 </span><br><span class="line">slow_query_log_file=/data/log/slow.log </span><br><span class="line">##针对log_queries_not_using_indexes开启后，记录慢sql的频次、每分钟记录的条数 </span><br><span class="line">#log_throttle_queries_not_using_indexes = 5 </span><br><span class="line">##作为从库时生效,从库复制中如何有慢sql也将被记录 </span><br><span class="line">#log_slow_slave_statements = 1 </span><br><span class="line">##检查未使用到索引的sql </span><br><span class="line">#log_queries_not_using_indexes = 1 </span><br><span class="line">#快速预热缓冲池 </span><br><span class="line">innodb_buffer_pool_dump_at_shutdown=1 </span><br><span class="line">innodb_buffer_pool_load_at_startup=1 </span><br><span class="line">#打印deadlock日志 </span><br><span class="line">innodb_print_all_deadlocks=1  </span><br></pre></td></tr></table></figure>



<h4 id="数据库结构设计和sql语句"><a href="#数据库结构设计和sql语句" class="headerlink" title="数据库结构设计和sql语句"></a>数据库结构设计和sql语句</h4><p>慢查询-&gt;数据库表结构设计</p>
<p>tis：sql语句的编写和优化和数据库表结构设计</p>
<ul>
<li>过分的反范式化为表建立太多列</li>
<li>过分的范式化造成太多的表关联</li>
<li>在OLTP环境使用不恰当的分区表</li>
<li>使用外键保证数据的完整性</li>
</ul>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>插件式存储引擎</p>
<p>第一层<strong>客户端：</strong>PHP、java、C API、.NET等（主要负责连接处理、授权认证、安全等功能）</p>
<p>第二层<strong>Mysql服务层：</strong>里面有连接管理器用于查询缓存，查询解析（查询解析下又有查询优化器）</p>
<p>select：如何从文件中获得我们所要的查询数据，这个具体的实现的方式则是由下一层存储引擎来实现的</p>
<p>第三层：<strong>存储引擎</strong>（注意：存储引擎是针对于表的，不是针对于库的）</p>
<p><img src="https://img-blog.csdn.net/20180511181017647?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhX2d1b19saQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><p>mysql5.5之前版本默认存储引擎，一般系统表、临时表是使用这种存储引擎，这里的临时表是指在排序、分组等操作中，当数量达到一定大小后，由查询优化器建立的临时表。</p>
<p>MyISAM存储引擎表是由MYD和MYI组成</p>
<p>特性：</p>
<ul>
<li><p>并发性和锁级别</p>
<p>MyISAM对整张表加锁，而不是行。读取程序在需要读取数据是，在所有表上都可以获取共享锁，而写入程序可以获取排他锁，用户在使用select查询时，可以同时在同一张表内插入新行（也称之为并发插入）。</p>
</li>
<li><p>自动修复：MYSQL支持对MyISAM表的自动检查和自动修复</p>
</li>
<li><p>手工修复：用户可以使用CHECK TABLE +表名称和REPAIR TABLE +表名称命令，检查表中的错误，并修复错误。</p>
</li>
<li><p>索引特性：在MyISAM表中，用户可以基于BLOB或TEXT类型列的前500个字符，创建相关索引，MyISAM支持全文索引，它可以根据个别单词，为复杂的搜索选项创建相关索引。</p>
</li>
<li><p>延迟更新索引：使用表创建选项DELAY_KEY_WRITE创建的MyISAM表，在查询结束后，不会将索引的改变数据写入磁盘，而是在内存的缓冲区中缓存索引改变数据，它只会在清理清理缓冲区或者是关闭表时，才将索引块转存到磁盘。对于数据经常改变，并且使用频繁的表，这种模式大大提高了表的处理性能，但是如果服务器或者系统崩溃，索引肯定埙怀，并需要修复。用户可以使用脚本，如运行myisamchk工具，在重启服务器前进行修复， 也可以使用自动修复选项修复。延迟更新索引特性可以被全剧配置，也可以为个别表单独配置。</p>
</li>
<li><p>压缩的MyISAM表：对与一些数据创建和填写以后永不改变的数据，非常适合选用压缩的MyISAM表，使用myisampack工具，可以对表进行压缩或者打包，压缩表一般是不能改变的，其占用磁盘空间小，使之可以提供更快的表处理性能。压缩MyISAM表也可以拥有索引，但这些索引也是只读的。</p>
</li>
</ul>
<p>限制：</p>
<p>版本&lt;mysql5.0时默认表大小为4G</p>
<p>如存储大表则要修改MAX-Rows和AVG_ROW_LENGTH</p>
<p>版本&gt;Mysql5.0时候默认支持256TB</p>
<p>使用场景:</p>
<ul>
<li>非事务型应用</li>
<li>只读类应该</li>
<li>空间类应用</li>
</ul>
<h5 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h5><p>MYsql5.5及之后版本默认存储引擎</p>
<p>使用表空间进行的，数据存储，支持事务，而且是行级锁； InnDB引擎支持事务，其特点是行锁设计，支持外键。InnODB引擎默认读取不会产生锁。从5.5.8版本开始InnoDB是默认存储引擎。InnoDB使用多版本并发控制（MVCC）来获得高并发性，且实现了SQL标准的4种隔离级别，默认为repeatable级别。同时使用一种next-key-locking的策略来避免幻读现象的产生。对于表中数据的存储，InnoDB采用了聚集的方式，一次每张表的存储都是按主键的顺序进行存放。如果没有显示的在表定义时制定主键，InnoDB会为每一行生成一个6字节的rowid，并以此为主键。</p>
<h2 id="MySQL存储引擎InnoDB与Myisam的六大区别："><a href="#MySQL存储引擎InnoDB与Myisam的六大区别：" class="headerlink" title="MySQL存储引擎InnoDB与Myisam的六大区别："></a>MySQL存储引擎InnoDB与Myisam的六大区别：</h2><p>MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎：</p>
<ul>
<li><p>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。</p>
</li>
<li><p>MEMORY存储引擎提供”内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。</p>
<p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。</p>
</li>
<li><p>InnoDB和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。</p>
</li>
<li><p>EXAMPLE存储引擎是一个”存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。</p>
</li>
<li><p>NDB Cluster是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p>
</li>
<li><p>ARCHIVE存储引擎被用来无索引地，非常小地覆盖存储的大量数据。</p>
</li>
<li><p>CSV存储引擎把数据以逗号分隔的格式存储在文本文件中。</p>
</li>
<li><p>BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。</p>
</li>
<li><p>FEDERATED存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><strong>MyISAM</strong></th>
<th><strong>InnoDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>构成上的区别：</strong></td>
<td>每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。   .frm文件存储表定义。   数据文件的扩展名为.MYD (MYData)。   索引文件的扩展名是.MYI (MYIndex)。</td>
<td>基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB</td>
</tr>
<tr>
<td>事务处理上方面</td>
<td>MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持</td>
<td>InnoDB提供事务支持事务，外部键（foreign key）等高级数据库功能</td>
</tr>
<tr>
<td>SELECT  UPDATE,INSERT，Delete操作</td>
<td>如果执行大量的SELECT，MyISAM是更好的选择</td>
<td></td>
</tr>
<tr>
<td>对AUTO_INCREMENT的操</td>
<td>每表一个AUTO_INCREMEN列的内部处理。   MyISAM为INSERT和UPDATE操作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。(当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况）。   AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置   对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引   更好和更快的auto_increment处理</td>
<td>如果你为一个表指定AUTO_INCREMENT列，在数据词典里的InnoDB表句柄包含一个名为自动增长计数器的计数器，它被用在为该列赋新值。   自动增长计数器仅被存储在主内存中，而不是存在磁盘上   关于该计算器的算法实现，请参考   <strong>AUTO_INCREMENT**</strong>列在**<strong>InnoDB**</strong>里如何工作**</td>
</tr>
<tr>
<td><strong>表的具体行数</strong></td>
<td>select count(<em>) from table,MyISAM只要简单的读出保存好的行数，注意的是，当count(</em>)语句包含  where条件时，两种表的操作是一样的</td>
<td>InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行</td>
</tr>
<tr>
<td><strong>锁</strong></td>
<td>表锁</td>
<td>提供行锁(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-locking read in   SELECTs)，另外，InnoDB表的行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表， 例如update table set num=1 where name like “%aaa%”</td>
</tr>
</tbody></table>
<p>更具体：参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html">https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html</a></p>
<h3 id="性能优化顺序"><a href="#性能优化顺序" class="headerlink" title="性能优化顺序"></a>性能优化顺序</h3><ul>
<li><p>数据库结构设计和sql语句</p>
<p>数据库结构设计优化的目的：</p>
<ul>
<li><p>尽量（而不是完全）减少数据的冗余</p>
</li>
<li><p>尽量避免数据维护中出现更新，插入和删除异常</p>
<p>插入异常：如果表中的某个实体随着另一个实体而存在</p>
<p>更新异常：如果更改表中的某个实体的单独属性时，需要对多行数据进行跟新</p>
<p>删除异常：如果删除表中某一个实体则会导致其他实体的消失</p>
</li>
<li><p>节约数据库的存储空间</p>
</li>
<li><p>提高查询效率</p>
</li>
</ul>
</li>
</ul>
<p>​         数据库数据范式：</p>
<p>​            目的：设计出没有数据冗余和没有数据库维护异常的数据库结构</p>
<h6 id="一般数据库三范式："><a href="#一般数据库三范式：" class="headerlink" title="一般数据库三范式："></a>一般数据库三范式：</h6><p>​            <strong>第一范式：</strong></p>
<p>​            1.数据库表中的所有字段都只具有单一属性</p>
<p>​            2.单一属性的列是由基本的数据类型所构成的</p>
<p>​            3.设计出来额表都是简单的二维表</p>
<p>​            <strong>第二范式：</strong></p>
<p>​            1.第二范式是在第一范式基础上的</p>
<p>​            2.要求一个表总具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对指对部门主键的依赖关系</p>
<p>​            <strong>第三范式：</strong></p>
<p>​            1.第三范式是在第二范式的基础上的</p>
<p>​            2.指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也接是在第二范式基础上消除了非主属性对主键的传递依赖</p>
<p>注意：关联表越多查询性能越差，所以不一定完全范式化；完全范式化的设计不一定得到良好的sql查询。</p>
<p>​            什么叫做反范式化设计：</p>
<p>​            反范式化是针对范式化而言的，所谓的反范式化就是为了性能和读取效率的考虑而适当对数据库设计范式的要求进行违反，而且允许存在少量的数据冗余，换句话来说接是使用空间换取时间。</p>
<p><strong>范式化和的优缺点：</strong></p>
<p>缺点： </p>
<p>​     对于查询所需要对多个表进行关联</p>
<p>​    更难进行索引优化</p>
<p> 优点：</p>
<pre><code>  可以尽量的减少数据冗余

  范式化的更新操作比反范式化更快</code></pre>
<p>​      范式化的表通常比反范式化更小</p>
<p><strong>反范式化优缺点：</strong></p>
<p>优点：</p>
<p>​     可以减少表的关联</p>
<p>​     可用更好的进行索引优化</p>
<p>缺点：</p>
<p>​     存在数据冗余和数据维护异常</p>
<p>​     对数据的修改需要更多的成本</p>
<ul>
<li>数据库存储引擎的选择和参数配置</li>
<li>系统选择及优化</li>
<li>硬件升级</li>
</ul>
<p>数据设计一般都是范式化和反范式化结合</p>
<h6 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h6><ul>
<li><p>定义数据库、表及字段的命名规范</p>
<p>数据库、表及字段的命名要遵循<strong>可读性原则</strong></p>
<p>数据库、表及字段的命名要遵循<strong>表意性原则</strong></p>
<p>数据库、表及字段的命名要遵循<strong>长名原则</strong></p>
</li>
<li><p>选择合适的存储引擎</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/20191011191035889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p>为表中的字段选择合适的数据类型</p>
<p>当一个列可用选择多种数据类型时，应当优先考虑数字类型，其次是日期或者二进制类型，最后是字符串。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。</p>
<p><strong>整数类型：</strong></p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>所占空间**</strong>(<strong>**字节)</strong></th>
<th><strong>带符号</strong></th>
<th><strong>无符号</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>最小值</strong></td>
<td><strong>最大值</strong></td>
<td><strong>最小值</strong></td>
<td><strong>最大值</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tinyint</td>
<td>1</td>
<td>-128</td>
<td>127</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>smallint</td>
<td>2</td>
<td>-32768</td>
<td>32767</td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>mediumint</td>
<td>3</td>
<td>-8388608</td>
<td>8388607</td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648</td>
<td>2147483647</td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>bigint</td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody></table>
</li>
</ul>
<p>​         <strong>实数类型：</strong></p>
<table>
<thead>
<tr>
<th>FLOAT</th>
<th>4 字节</th>
<th>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</th>
<th>0，(1.175 494 351 E-38，3.402 823 466 E+38)</th>
<th>单精度  浮点数值</th>
</tr>
</thead>
<tbody><tr>
<td>DOUBLE</td>
<td>8 字节</td>
<td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td>双精度  浮点数值</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody></table>
<p>​         <strong>VARCHAR和CHAR类型：</strong></p>
<p>varchar类型用于存储可变长的字符串，是比较常见常用的字符串数据类型，在存储的字符串是变长时，varchar更加节约空间。由于varchar是变长的，在使用update的时候，可能使得行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增加，并且在页内没有多余的空间可与存储，这是innoDB的存储引擎需要分裂页来使行可以放进页内。</p>
<p>char类型是定长的。在存储数据时，MySQL会删除所有文末的空格，所以，即便你存储的是：’abc ‘，注意这个字符串末尾是有空格的，也会在存储时把这个空格删掉，这点需要注意。</p>
<h3 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>varchar适用的场景：</p>
<ul>
<li>字符串列的最大长度比平均长度要大很多；</li>
<li>字符串列的更新很少时，因为没有或很少有内存碎片问题；</li>
<li>使用了UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储；</li>
</ul>
<p>char适用的场景：</p>
<ul>
<li>列的长度为定值时适合适用，比如：MD5密文数据</li>
</ul>
<h3 id="varchar和char的优缺点"><a href="#varchar和char的优缺点" class="headerlink" title="varchar和char的优缺点"></a>varchar和char的优缺点</h3><p><strong>varchar的优点：</strong></p>
<ul>
<li>变长的字符串类型，兼容性更好</li>
</ul>
<p><strong>varchar的缺点：</strong></p>
<ul>
<li>使用varchar可能会产生内存碎片</li>
<li>varchar会额外需要1到2个字节存储长度信息</li>
<li>update语句可能会导致页分裂</li>
</ul>
<p><strong>char的优点：</strong></p>
<ul>
<li>定长的字符串类型，减少内存碎片</li>
<li>无需额外的内存空间去存储长度信息</li>
</ul>
<p><strong>char的缺点：</strong></p>
<ul>
<li><p>会删除列末尾的空格信息</p>
<p><strong>日期的选择：</strong></p>
<p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小  (字节)</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01/9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>‘-838:59:59’/‘838:59:59’</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:00/2037 年某时</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h3><p>基准测试：直接、简单、易于比较，用于评估服务器的处理能力</p>
<p>压力测试：对真实业务数据进行测试，获得真实系统所能承受的压力</p>
<ul>
<li>压力测试需要针对不同的主题。所使用的数据和查询也是真实用到的</li>
<li>基准测试可能不关心业务逻辑，所使用的查询和业务的真实性可用和业务环境无关</li>
</ul>
<p>基准测试的目的：</p>
<ul>
<li>建立mysql服务器的性能基准线</li>
<li>模拟比当前系统更高的负载，以找出系统拓展的瓶颈</li>
<li>测不通的硬件、软件和操作系统配置</li>
<li>证明新的硬件设备是否配置正确</li>
</ul>
<h3 id="后续更新"><a href="#后续更新" class="headerlink" title="后续更新"></a>后续更新</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>了解索引前，先了解一些数据结构：</strong></p>
<p>二叉查找/搜索/排序树  BST  (binary search/sort tree)<br>或者是一棵空树；<br>或者是具有下列性质的二叉树：<br>（1）若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序树。</p>
<p><img src="https://img-blog.csdn.net/20181004102705475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>注意：对二叉查找树进行中序遍历，得到有序集合。</p>
<p>平衡二叉树（Self-balancing binary search tree）  自平衡二叉查找树  又被称为AVL树（有别于AVL算法）<br>它是一 棵空树<br>或它的左右两个子树的高度差(平衡因子)的绝对值不超过1，<br>并且左右两个子树都是一棵平衡二叉树，<br>同时，平衡二叉树必定是二叉搜索树，反之则不一定</p>
<p> 平衡因子（平衡度）：结点的平衡因子是结点的左子树的高度减去右子树的高度。（或反之定义）<br> 平衡二叉树：每个结点的平衡因子都为 1、－1、0 的二叉排序树。或者说每个结点的左右子树的高度最多差1的二叉排序树。</p>
<p>平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度</p>
<p>平衡二叉树的常用实现方法有AVL、红黑树、替罪羊树、Treap、伸展树等</p>
<p><img src="https://img-blog.csdn.net/20181004102938486?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>红黑树<br>   R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种平衡二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>注意：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树<br><img src="https://img-blog.csdn.net/2018100410311231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5cXdpbGxpYW0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。<br>   它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。<br>   例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><h2 id="B-树是一种多路搜索树（并不一定是二叉的）"><a href="#B-树是一种多路搜索树（并不一定是二叉的）" class="headerlink" title="B-树是一种多路搜索树（并不一定是二叉的）"></a>B-树是一种多路搜索树（并不一定是二叉的）</h2><p>1970年，R.Bayer和E.mccreight提出了一种适用于外查找的树，它是一种平衡的多叉树，称为B树（或B-树、B_树）。</p>
<h2 id="一棵m阶B树-balanced-tree-of-order-m-是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树："><a href="#一棵m阶B树-balanced-tree-of-order-m-是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：" class="headerlink" title="一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树："></a>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</h2><p>1、根结点至少有两个子女；</p>
<p>2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；</p>
<p>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ &lt;= k &lt;= m ；</p>
<p>4、所有的叶子结点都位于同一层。</p>
<h1 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h1><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的</p>
<p>子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<h2 id="如：（M-3）"><a href="#如：（M-3）" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h2><p><img src="https://img-blog.csdn.net/20160805191715603" alt="这里写图片描述"></p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</p>
<p>命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</p>
<p>空，或已经是叶子结点；</p>
<h1 id="B-树的特性："><a href="#B-树的特性：" class="headerlink" title="B-树的特性："></a>B-树的特性：</h1><p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p>
<h1 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h1><p>B+ 树通常用于<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/14">数据库</a>和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。</p>
<h1 id="B-树的定义"><a href="#B-树的定义" class="headerlink" title="B+树的定义"></a>B+树的定义</h1><h2 id="B-树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B-树和m阶的B-树的差异在于："><a href="#B-树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B-树和m阶的B-树的差异在于：" class="headerlink" title="B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于："></a>B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</h2><p>1.有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
<p>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。<br>通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>
<h2 id="B-树是B-树的变体，也是一种多路搜索树："><a href="#B-树是B-树的变体，也是一种多路搜索树：" class="headerlink" title="B+树是B-树的变体，也是一种多路搜索树："></a>B+树是B-树的变体，也是一种多路搜索树：</h2><p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；</p>
<h2 id="如：（M-3）-1"><a href="#如：（M-3）-1" class="headerlink" title="如：（M=3）"></a>如：（M=3）</h2><p><img src="https://img-blog.csdn.net/20160805192039968" alt="这里写图片描述"><br>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p>
<p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<h1 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h1><p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</p>
<p>是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</p>
<p>（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h1 id="B-树："><a href="#B-树：" class="headerlink" title="B*树："></a>B*树：</h1><h2 id="是B-树的变体，在B-树的非根和非叶子结点再增加指向兄弟的指针；"><a href="#是B-树的变体，在B-树的非根和非叶子结点再增加指向兄弟的指针；" class="headerlink" title="是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；"></a>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</h2><p><img src="https://img-blog.csdn.net/20160805192156312" alt="这里写图片描述"></p>
<h2 id="B-树定义了非叶子结点关键字个数至少为-2-3-M，即块的最低使用率为2-3"><a href="#B-树定义了非叶子结点关键字个数至少为-2-3-M，即块的最低使用率为2-3" class="headerlink" title="B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3"></a>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</h2><p>（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</p>
<p>复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</p>
<p>结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</p>
<p>数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</p>
<p>（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</p>
<p>间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><h2 id="B-树：-1"><a href="#B-树：-1" class="headerlink" title="B-树："></a>B-树：</h2><p>多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键</p>
<p>字范围的子结点；</p>
<p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<h2 id="B-树：-2"><a href="#B-树：-2" class="headerlink" title="B+树："></a>B+树：</h2><p>在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点</p>
<p>中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<h2 id="B-树：-3"><a href="#B-树：-3" class="headerlink" title="B*树："></a>B*树：</h2><p>在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率</p>
<p>从1/2提高到2/3；</p>
<p><strong>索引</strong></p>
<p>mysmas的索引的记录节点是根据数据的物理位置</p>
<p>innodb则是通过主键来引用B-thee的行</p>
<p>B-tree索引的特点：</p>
<ul>
<li>B-tree索引能够加快数据的查询速度</li>
<li>B-tree索引更加合适进行范围查找</li>
</ul>
<p>在什么情况下可以用到B树索引</p>
<ul>
<li><p>全值匹配的查询</p>
<p>如：order_sn = “443434”</p>
</li>
<li><p>匹配最左前缀的查询</p>
</li>
<li><p>匹配列前缀查询</p>
<p>order_sn like “3837%”</p>
</li>
<li><p>匹配范围值得查询</p>
<p>order_sn = ‘23233’</p>
</li>
<li><p>精确匹配做前列并范围匹配另外一列</p>
</li>
<li><p>只访问索引的查询</p>
</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>如果不是按照索引最左列开始查找，则无法使用索引</li>
<li>使用索引时不能跳过索引中的列</li>
<li>Not in 和 &lt;&gt;操作无法使用索引</li>
<li>如果查询中有个列的范围查询，则其右边所有列都无法使用索引</li>
</ul>
<p><strong>Hash索引的特点：</strong></p>
<ul>
<li>Hash索引时基于Hash表实现的，只有条件精确匹配，Hash索引中所有列时，才能够使用到hash索引</li>
<li>对于Hash索引中的所有列，存储引擎都会为每一行计算一个hash码，hash索引中存储的就是hash码</li>
</ul>
<p><strong>限制：</strong></p>
<ul>
<li>hash索引必须进行二次查找（但由于大量的行都是存在缓存，数据访问很快）</li>
<li>hash索引无法用于排序</li>
<li>hash索引不支持部分索引查找也不支持范围查找</li>
<li>hash索引中hash码的计算可能存在hash冲突</li>
</ul>
<h5 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h5><ul>
<li>索引大大减少了存储引擎需要扫描数据量</li>
<li>索引可以帮助我们进行排序以避免使用临时表</li>
<li>索引可以把随机io变为顺序io</li>
</ul>
<p>索引并不是越多越好：</p>
<ul>
<li>索引会增加写操作的成本，innodb通过把多次插入变成一次插入</li>
<li>太多索引会增加查询优化器的选择时间</li>
</ul>
<p><strong>索引优化策略：</strong></p>
<ul>
<li>索引列上不能使用表达式或者函数</li>
</ul>
<p>如：select …from product where to_day(out_date)-to_days(current_date)&lt;=30 这里to_day()是个函数， out_date是索引列</p>
<p>改为：select… from product where out_date&lt;= date_add(current_date,interval,interval 30 day)  out_date是索引列 </p>
<ul>
<li><p>前缀索引和索引列的选择性</p>
<p>create index index_name on table(col_name(n))    innodb最大值宽度767字节 mysmr是1000个字节</p>
<p>索引的选择性是不重复的索引值和表的记录数的比值</p>
</li>
<li><p>联合索引</p>
<p>如何选择索引的顺序：</p>
<ul>
<li>经常被使用到列优先（把优先级的放到联合索引最左边，因为索引是从左往右读取）</li>
<li>选择性高的列优先</li>
<li>宽度小的优先级（一般宽度小 读的时候io就比较小）</li>
</ul>
</li>
<li><p>覆盖索引</p>
<p>在了解覆盖索引之前我们先大概了解一下什么是聚集索引(主键索引)和辅助索引(二级索引)</p>
<p>​    聚集索引（主键索引）：</p>
<p>​      聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。</p>
<p>​      聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。</p>
<p>​    辅助索引（二级索引）：</p>
<p>​      非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。</p>
<p>​    再来看看什么是覆盖索引，有下面三种理解：</p>
<ul>
<li>解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li>
<li>解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</li>
<li>解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。</li>
</ul>
<p>　　不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</p>
<p>优点：</p>
<ul>
<li>可以优化缓存，减少磁盘IO操作</li>
<li>可以减少随机io，变随机io操作变为顺序io操作</li>
<li>可以避免对innodb主键索引的二次查询</li>
<li>可以避免myisam表进行系统调用</li>
</ul>
</li>
<li><p>无法使用场景：</p>
<ul>
<li>存储引擎并不是所有都支持覆盖索引</li>
<li>查询中使用太多列</li>
<li>使用了双%号的like查询</li>
</ul>
</li>
</ul>
<p><strong>使用索引来优化查询：</strong></p>
<ul>
<li>使用索引扫描来优化排序<ul>
<li>索引的列顺和order by字句的顺序完全一致</li>
<li>索引中的所有的方向（顺序，降序）和order by 完全一致</li>
<li>order by中的字段全部在关联表中的第一张表中</li>
</ul>
</li>
<li>模拟hash索引优化查询<ul>
<li>只能处理键值得全值匹配查询</li>
<li>所使用的hash函数决定着索引引键大小</li>
</ul>
</li>
<li>利用索引优化锁<ul>
<li>索引减少锁定的行数</li>
<li>索引可以加快处理速度，同时加快了锁的释放</li>
</ul>
</li>
</ul>
<p><strong>索引的维护和优化：</strong></p>
<ul>
<li><p>删除重复和冗余的索引</p>
<p>可以同过 pt -duplicate-key-checker h =127.0.0.1来检查</p>
</li>
<li><p>查找未被使用过的索引</p>
</li>
<li><p>更新索引统计信息减少索引碎片</p>
<p>analyze table table_name</p>
<p>optimize table table_name 使用不当会导致锁表</p>
</li>
</ul>
<h3 id="sql查询优化"><a href="#sql查询优化" class="headerlink" title="sql查询优化"></a>sql查询优化</h3><p><strong>如何获取有性能的sql</strong></p>
<ul>
<li><p>通过用户反馈获取存在性能问题的sql</p>
</li>
<li><p>通过慢查询日志获取存在性能问题的sql</p>
<p>存储日志所需要大量的磁盘空间</p>
<p>slow_query_log 启动停止记录慢查询日志 可以通过set global 来启动或者通过脚本定时执行</p>
<p>slow_query_log_file 制定慢查询日志的存储路径及文件</p>
<p>long_query_time 制定记录慢查询日志sql执行时间的阈值1.记录所有符合条件的sql2、包括查询语句3、数据修改语句4、已经回滚的sql 5、默认值是10s</p>
<p>慢查询日志分析工具（mysqlidumslow,pt-query-deges--explan h =127.0.0.1,u=root,p=p@ssword\slow-mysql.log）</p>
</li>
<li><p>实时获取存在性能问题的sql</p>
<p>通过PROCESSLIST表来获取</p>
</li>
</ul>
<h3 id="查询为什么会慢"><a href="#查询为什么会慢" class="headerlink" title="查询为什么会慢"></a>查询为什么会慢</h3><p>mysql处理查询的步骤：1.客户端发送sql请求给服务器</p>
<p>​                                          2.服务器检查是否可以在查询缓存中命中该sql</p>
<p>​                                          3.服务器端进行sql解析，预处理，再有优化器生成对应的执行计划</p>
<p>​                                          4.根据试行计划，条用存储引擎API查询数据</p>
<p>​                                          5.将结果返回给客户端</p>
<p><strong>mysql优化器可优化的sql类型：</strong></p>
<ul>
<li>重新定义表的关联顺序</li>
<li>将外连接转化成内连接</li>
<li>使用等价变换规则</li>
<li>优化cout（），min（），max（）函数</li>
<li>将一个表达式转化为常数表达式</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>对in（）条件进行优化</li>
</ul>
<p><strong>如何度量一个sql在执行的各个阶段所消耗的时间：</strong></p>
<p>查看各阶段所消耗的时间：</p>
<p><strong>- profile</strong></p>
<p>set profiling =1执行</p>
<p>show profiles</p>
<p>查看每一个查询所消耗的总时间的信息</p>
<p>show profile for  query N；</p>
<p>查询每个阶段的每一个查询消耗的值</p>
<p><strong>- preformance_schema</strong></p>
<h4 id="特定sql查询优化"><a href="#特定sql查询优化" class="headerlink" title="特定sql查询优化"></a>特定sql查询优化</h4><ul>
<li><p>大表的数据修改最好要分批处理</p>
</li>
<li><p>优化not in 和&lt;&gt;查询</p>
</li>
</ul>
<p>select id,name from customer where id not in (select id form payment)</p>
<p>优化后：select a.id,a.name from customer a left join payment b on a.id = b.id where b.id is null</p>
<ul>
<li>使用汇总表优化查询</li>
</ul>
<h3 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h3><p><strong>分库分表的几种方式：</strong></p>
<ul>
<li><p>比一个实例中多个数据库拆分到不同的实例</p>
<p>假如只是其中一个数据库的读写压力很大，则这种分库意义就不大了</p>
</li>
<li><p>把一个库中的表分离到不同的数据库中</p>
</li>
<li><p>表的水平拆分即对数据库分片处理</p>
</li>
</ul>
<p>数据库分片前的准备：</p>
<p>对一个库的相关表进行水平拆分到不同实例的数据库中</p>
<ul>
<li><p>如何选择分区键</p>
<ul>
<li>分区键要能尽可能避免跨分片查询的发生</li>
<li>分区键要尽可能使用各个分片中的数据平均</li>
</ul>
</li>
<li><p>如何存储无需分片的表</p>
<ul>
<li>没个分片中存储一份相同的数据</li>
<li>使用额外的节点同一存储</li>
</ul>
</li>
<li><p>如何在节点上部署分片</p>
<ul>
<li>每个分片使用单一的数据库，并且数据库名也相同</li>
<li>将多个分片存储在一个数据库中，并且在表明上假如分片号后缀</li>
<li>在一个节点中部署多个数据库，每个数据库中包含一个或者多个分片</li>
</ul>
</li>
<li><p>如何分配分片中的数据</p>
<ul>
<li>按分区键对的Hash值取模来分配分片数据</li>
<li>按分区键的范围来分配分片数据</li>
<li>利用分区键和分片的映射表来分配分片数据</li>
</ul>
</li>
<li><p>如何生成全局唯一ID</p>
<ul>
<li>使用auto_increment_increment和auto_increment_offset参数</li>
<li>使用全局节点生成id</li>
<li>在Redis等缓存服务器中创建全局id</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/mysql/" rel="tag"># mysql</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/21/HEXO-NEXT%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/" rel="next" title="HEXO+NEXT界面美化">
                <i class="fa fa-chevron-left"></i> HEXO+NEXT界面美化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DailyZeroZip" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">1.</span> <span class="nav-text">Mysql性能调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E4%BA%86%E5%8F%8C11%E5%A4%A7%E4%BF%83%E7%9A%84%E6%88%90%E8%B4%A5"><span class="nav-number">1.0.1.</span> <span class="nav-text">什么决定了双11大促的成败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="nav-number">1.0.2.</span> <span class="nav-text">影响数据库的因素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sql%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">sql查询速度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E5%8D%A1%E6%B5%81%E9%87%8F"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">网卡流量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">服务器硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98io"><span class="nav-number">1.0.2.4.</span> <span class="nav-text">磁盘io</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%98%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD"><span class="nav-number">1.0.2.5.</span> <span class="nav-text">其他还会影响数据库性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">1.0.2.5.1.</span> <span class="nav-text">大表给我们带来的问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E4%BA%8B%E5%8A%A1%E7%BB%99%E6%88%91%E4%BB%AC%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="nav-number">1.0.2.5.2.</span> <span class="nav-text">大事务给我们带来的影响：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%E4%BA%86%E6%80%A7%E8%83%BD"><span class="nav-number">1.0.3.</span> <span class="nav-text">什么影响了性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6-1"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">服务器硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">服务器操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">数据库存储引擎的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">数据库参数配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8Csql%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.0.3.5.</span> <span class="nav-text">数据库结构设计和sql语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql"><span class="nav-number">1.0.4.</span> <span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM"><span class="nav-number">1.0.4.1.1.</span> <span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Innodb"><span class="nav-number">1.0.4.1.2.</span> <span class="nav-text">Innodb</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EInnoDB%E4%B8%8EMyisam%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">MySQL存储引擎InnoDB与Myisam的六大区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">性能优化顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.1.1.0.0.1.</span> <span class="nav-text">一般数据库三范式：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.1.1.0.0.2.</span> <span class="nav-text">物理设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.2.</span> <span class="nav-text">适用的场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#varchar%E5%92%8Cchar%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.3.</span> <span class="nav-text">varchar和char的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">1.1.4.</span> <span class="nav-text">MySQL基准测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E6%9B%B4%E6%96%B0"><span class="nav-number">1.1.5.</span> <span class="nav-text">后续更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.6.</span> <span class="nav-text">索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">B-树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AF%E4%B8%80%E7%A7%8D%E5%A4%9A%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E4%BA%8C%E5%8F%89%E7%9A%84%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">B-树是一种多路搜索树（并不一定是二叉的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%A3%B5m%E9%98%B6B%E6%A0%91-balanced-tree-of-order-m-%E6%98%AF%E4%B8%80%E6%A3%B5%E5%B9%B3%E8%A1%A1%E7%9A%84m%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%82%E5%AE%83%E6%88%96%E8%80%85%E6%98%AF%E7%A9%BA%E6%A0%91%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E6%BB%A1%E8%B6%B3%E4%B8%8B%E5%88%97%E6%80%A7%E8%B4%A8%E7%9A%84%E6%A0%91%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">特点：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%EF%BC%9A%EF%BC%88M-3%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">如：（M&#x3D;3）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">B-树的特性：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91-1"><span class="nav-number">5.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">用途：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.</span> <span class="nav-text">B+树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AF%E5%BA%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%89%80%E9%9C%80%E8%80%8C%E5%87%BA%E7%9A%84%E4%B8%80%E7%A7%8DB-%E6%A0%91%E7%9A%84%E5%8F%98%E5%9E%8B%E6%A0%91%E3%80%82%E4%B8%80%E6%A3%B5m%E9%98%B6%E7%9A%84B-%E6%A0%91%E5%92%8Cm%E9%98%B6%E7%9A%84B-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%98%AFB-%E6%A0%91%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E5%A4%9A%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">B+树是B-树的变体，也是一种多路搜索树：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%EF%BC%9A%EF%BC%88M-3%EF%BC%89-1"><span class="nav-number">7.3.</span> <span class="nav-text">如：（M&#x3D;3）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">B+的特性：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-%E6%A0%91%EF%BC%9A"><span class="nav-number">9.</span> <span class="nav-text">B*树：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AFB-%E6%A0%91%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%8C%E5%9C%A8B-%E6%A0%91%E7%9A%84%E9%9D%9E%E6%A0%B9%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%86%8D%E5%A2%9E%E5%8A%A0%E6%8C%87%E5%90%91%E5%85%84%E5%BC%9F%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%9B"><span class="nav-number">9.1.</span> <span class="nav-text">是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E5%AE%9A%E4%B9%89%E4%BA%86%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%AA%E6%95%B0%E8%87%B3%E5%B0%91%E4%B8%BA-2-3-M%EF%BC%8C%E5%8D%B3%E5%9D%97%E7%9A%84%E6%9C%80%E4%BD%8E%E4%BD%BF%E7%94%A8%E7%8E%87%E4%B8%BA2-3"><span class="nav-number">9.2.</span> <span class="nav-text">B*树定义了非叶子结点关键字个数至少为(2&#x2F;3)*M，即块的最低使用率为2&#x2F;3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="nav-number">10.</span> <span class="nav-text">小结：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%EF%BC%9A-1"><span class="nav-number">10.1.</span> <span class="nav-text">B-树：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%EF%BC%9A-2"><span class="nav-number">10.2.</span> <span class="nav-text">B+树：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%EF%BC%9A-3"><span class="nav-number">10.3.</span> <span class="nav-text">B*树：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">10.3.0.0.1.</span> <span class="nav-text">为什么要使用索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">10.3.1.</span> <span class="nav-text">sql查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%85%A2"><span class="nav-number">10.3.2.</span> <span class="nav-text">查询为什么会慢</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E5%AE%9Asql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">10.3.2.1.</span> <span class="nav-text">特定sql查询优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">10.3.3.</span> <span class="nav-text">数据库分库分表</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dzh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
